## Задачи на закрепление
Вот небольшие задачи на основные поведенческие паттерны с объяснением требований. Эти задания помогут лучше понять, как работают паттерны и где они применимы.

---

### 1. **Chain of Responsibility** (Цепочка обязанностей)

**Задание**: Реализуйте систему для обработки сообщений, в которой каждый уровень обработки проверяет сообщение на наличие спама, обидных слов и соответствие формату. Создайте три обработчика:
- **SpamHandler** – проверяет, является ли сообщение спамом (например, содержит "Buy now" или "Discount").
- **OffensiveHandler** – проверяет на наличие обидных слов (например, "bad" или "ugly").
- **FormatHandler** – проверяет, чтобы сообщение начиналось с заглавной буквы.

Если обработчик обнаружит нарушение, он выведет сообщение о его причине и прервет цепочку.

**Цель**: Научиться передавать запросы по цепочке обработчиков, пока запрос не обработается или не завершится.

---

### 2. **Command** (Команда)

**Задание**: Создайте консольное приложение для управления музыкальным плеером с командами: «Play», «Stop» и «Next». Каждая команда выполняет определенное действие:
- **PlayCommand** – запускает воспроизведение.
- **StopCommand** – останавливает воспроизведение.
- **NextCommand** – переходит к следующему треку.

Добавьте интерфейс для команд и класс **RemoteControl** с функцией установки команды и её выполнения.

**Цель**: Понять, как инкапсулировать действия в отдельные классы и динамически менять команды.

---

### 3. **Interpreter** (Интерпретатор)

**Задание**: Напишите простую программу для расчета выражений с «и» и «или». Например, если есть выражение **A ИЛИ (B И C)**, программа должна вернуть результат выражения, учитывая, что **A, B и C** – это логические переменные.

Создайте классы для **AndExpression** и **OrExpression** и основной интерфейс **Expression**. Пусть выражения принимают значения переменных и вычисляют итог.

**Цель**: Разобраться в интерпретации и обработке простого языка для вычислений.

---

### 4. **Iterator** (Итератор)

**Задание**: Создайте класс **BookCollection**, представляющий коллекцию книг, и **BookIterator** для перебора этой коллекции. Пусть коллекция содержит книгу с названием и автором.

Реализуйте метод, который возвращает итератор, чтобы вывести названия всех книг из **BookCollection** в цикле.

**Цель**: Понять, как работает итерация объектов внутри коллекции без раскрытия её внутренней структуры.

---

### 5. **Observer** (Наблюдатель)

**Задание**: Реализуйте новостной канал и подписчиков, которые получают уведомления о новых статьях. В классе **NewsChannel** создайте методы для добавления/удаления подписчиков и отправки новостей.

Каждый подписчик должен иметь свой метод **receiveNews**, выводящий новость на экран.

**Цель**: Освоить создание и обновление подписчиков, реагирующих на изменения источника данных.

---

### 6. **Visitor** (Посетитель)

**Задание**: Создайте приложение для расчета общей стоимости товаров в корзине. Пусть в корзине есть **Book** и **Electronics**, и каждая из категорий имеет свою цену.

Создайте посетителя **CartVisitor**, который вычисляет итоговую стоимость, учитывая скидки для разных типов товаров (например, книги – скидка 10%, электроника – скидка 5%).

**Цель**: Освоить добавление логики к классу без его изменения.

---

### 7. **Mediator** (Посредник)

**Задание**: Создайте класс **ChatRoom**, управляющий взаимодействием между пользователями в чате. Каждый пользователь отправляет сообщения через посредника, который передает их другим пользователям.

При отправке сообщения посредник передает его всем пользователям в комнате, кроме отправителя.

**Цель**: Понять роль централизованного посредника для упрощения взаимодействий.

---

### 8. **State** (Состояние)

**Задание**: Разработайте простую систему для управления заказом. Заказ может находиться в состоянии **Created** (создан), **Paid** (оплачен) и **Shipped** (отправлен). Для каждого состояния реализуйте действия перехода к следующему состоянию.

Реализуйте метод, который меняет состояние заказа и выводит текущий статус на экран.

**Цель**: Научиться управлять изменяющимся поведением объекта в зависимости от состояния.

---

### 9. **Memento** (Снимок)

**Задание**: Создайте приложение для рисования, которое позволяет отменить последнее действие. Пусть класс **DrawingApp** имеет метод **addShape** для добавления фигуры и метод **undo** для отмены последнего добавления.

Добавьте поддержку сохранения состояния приложения через класс **Memento**, который хранит состояния добавленных фигур.

**Цель**: Освоить сохранение и восстановление состояния объекта, чтобы реализовать функционал отмены.